#!/bin/bash

#Â Shell-neutral functions.

# Remove duplicate elements from a $PATH-like variable while preserving order.
# This cannot use gawk features because it needs to be portable to Mac OS X.
deduplicate_path() {
  awk -F : \
      'BEGIN { output = ""; };
       { for (i = 1; i <= NF; i++) {
           if (!($i in seen)) {
             seen[$i] = 1;
             output = output ":" $i;
           }
         }
       }
       END { sub("^:", "", output); print output; }' <<< "$1"
}

# I might manually call this with -f, so disable the check.
# shellcheck disable=SC2120
update_ssh_auth_sock() {
  local force_update=0
  if [ "$#" -eq 1 ] && [ "$1" == "-f" ]; then
    force_update=1
  fi
  if [ -z "${SSH_AUTH_SOCK:-}" ]; then
    if [ -n "${SUDO_USER:-}" ]; then
      # No ssh forwarding when using sudo, so don't complain.
      return
    fi
    printf "Empty SSH_AUTH_SOCK!  ssh forwarding broken?\\n" >&2
    return 1
  fi

  local dir="${HOME}/tmp/ssh"
  if [ ! -d "${dir}" ]; then
    mkdir -p "${dir}"
    chmod 700 "${dir}"
  fi
  if [ -z "${ORIG_SSH_AUTH_SOCK:-}" ]; then
    if grep -q "${dir}" <<<"${SSH_AUTH_SOCK}"; then
      printf "\$%s is already in %s, but \$%s is not set\\n" \
        "SSH_AUTH_SOCK" "${dir}" "ORIG_SSH_AUTH_SOCK" >&2
      return 1
    fi
    ORIG_SSH_AUTH_SOCK="${SSH_AUTH_SOCK}"
    readonly ORIG_SSH_AUTH_SOCK
  fi
  SSH_AUTH_SOCK="${dir}/ssh-auth-sock-${HOSTNAME/lan/local}-${USER}"
  # Skip checks if -f was passed.
  if [ "${force_update}" -eq 0 ] && [ -e "${SSH_AUTH_SOCK}" ]; then
    # If the link points at a newer file do not update it to point to our file.
    if [ "${SSH_AUTH_SOCK}" -nt "${ORIG_SSH_AUTH_SOCK}" ]; then
      case "${ORIG_SSH_AUTH_SOCK}" in
        /private/tmp/com.apple.launchd*/Listeners)
          # The socket was created by launchd, so I must be logged in directly
          # on the machine, so I should be using that socket even if there is
          # another socket from sshing in from elsewhere.
          true
          ;;
        /tmp/ssh-*/agent.*)
          printf "%s is newer than %s, not changing; use -f to force\\n" \
            "${SSH_AUTH_SOCK}" "${ORIG_SSH_AUTH_SOCK}"
          return
          ;;
        *)
          printf "Unknown socket, not replacing: %s\\n" \
            "${ORIG_SSH_AUTH_SOCK}" >&2
          return
          ;;
      esac
    fi
  fi
  ln -s -f -n "${ORIG_SSH_AUTH_SOCK}" "${SSH_AUTH_SOCK}"
}

# Function to be run every time my prompt is displayed.
function prompt_command() {
  exit_status="$?"
  # Exit status 146/148 happens when you suspend something.
  case "${exit_status}" in
    0|146|148)
      :
      ;;
    *)
      printf "\\033[01;31mExit status: %s\\033[0m" "${exit_status}"
      ;;
  esac
  if [ -z "${TMUX:-}" ]; then
    # Set the xterm title.  Tmux does this if it's running.
    printf "\\033]0;%s on %s\\007" "${SHELL##*/}" "${HOSTNAME}"
  else
    if [ "${USER}" != "johntobin" ]; then
      # Put the user in the tmux pane title to warn me it's a different user.
      tmux rename-window -t "${TMUX_PANE}" "${USER}"
    fi
  fi
  if [ -z "${TMUX:-}" ]; then
    # Any shell running under tmux should already have the right environment.
    # shellcheck disable=SC2119
    update_ssh_auth_sock
  fi
  prompt_command_shell_specific
  prompt_command_extras
}
prompt_command_shell_specific() {
  true
}
prompt_command_extras() {
  true
}
